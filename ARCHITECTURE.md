# Vizuara æŠ€æœ¯æ¶æ„æ–‡æ¡£

> **ç‰ˆæœ¬**: v2.0  
> **æœ€åæ›´æ–°**: 2025å¹´8æœˆ28æ—¥  
> **æ¶æ„çŠ¶æ€**: ç¨³å®šï¼ŒæŒç»­ä¼˜åŒ–ä¸­

## ğŸ“– æ¶æ„æ¦‚è§ˆ

### ğŸ¯ è®¾è®¡åŸåˆ™

**Vizuara** çš„æ¶æ„è®¾è®¡éµå¾ªä»¥ä¸‹æ ¸å¿ƒåŸåˆ™ï¼š

1. **æ¨¡å—åŒ–è‡³ä¸Š**: æ¯ä¸ªåŠŸèƒ½æ¨¡å—éƒ½æ˜¯ç‹¬ç«‹çš„ crateï¼ŒèŒè´£æ¸…æ™°ï¼Œä¾èµ–æ˜ç¡®
2. **æ€§èƒ½ä¼˜å…ˆ**: åˆ©ç”¨ Rust é›¶æˆæœ¬æŠ½è±¡å’Œç°ä»£ GPU æŠ€æœ¯å®ç°æè‡´æ€§èƒ½
3. **ç±»å‹å®‰å…¨**: åœ¨ç¼–è¯‘æ—¶æ•è·é”™è¯¯ï¼Œç¡®ä¿è¿è¡Œæ—¶ç¨³å®šæ€§
4. **å¯æ‰©å±•æ€§**: æ”¯æŒæ’ä»¶å¼æ‰©å±•å’Œè‡ªå®šä¹‰ç»„ä»¶
5. **è·¨å¹³å°**: ç»Ÿä¸€çš„ APIï¼Œå¤šå¹³å°ä¸€è‡´çš„ç”¨æˆ·ä½“éªŒ

### ğŸ—ï¸ æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ç”¨æˆ·æ¥å£å±‚                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  vizuara-window    â”‚  Pythonç»‘å®š   â”‚  Webæ¥å£   â”‚  CLIå·¥å…·   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        åº”ç”¨é€»è¾‘å±‚                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  vizuara-plots  â”‚ vizuara-3d  â”‚ vizuara-animation â”‚ examples â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        åŠŸèƒ½æœåŠ¡å±‚                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ interactivity â”‚  themes  â”‚  export  â”‚  layout  â”‚ components â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        æ¸²æŸ“å¼•æ“å±‚                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     vizuara-wgpu     â”‚      vizuara-scene                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        æ ¸å¿ƒåŸºç¡€å±‚                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     vizuara-core                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ç³»ç»Ÿå¹³å°å±‚                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    wgpu    â”‚   winit   â”‚  nalgebra  â”‚   ç³»ç»Ÿå›¾å½¢é©±åŠ¨          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ§± æ¨¡å—æ¶æ„è¯¦è§£

### ğŸ”§ æ ¸å¿ƒåŸºç¡€å±‚

#### `vizuara-core`
**èŒè´£**: æä¾›åŸºç¡€æ•°æ®ç»“æ„ã€åæ ‡ç³»ç»Ÿã€é”™è¯¯å¤„ç†ç­‰æ ¸å¿ƒåŠŸèƒ½

```rust
// æ ¸å¿ƒæ¨¡å—ç»“æ„
vizuara-core/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs              // å…¬å…± API å¯¼å‡º
â”‚   â”œâ”€â”€ coords.rs           // åæ ‡ç³»ç»Ÿå’Œå˜æ¢
â”‚   â”œâ”€â”€ primitive.rs        // åŸºç¡€å‡ ä½•å›¾å½¢
â”‚   â”œâ”€â”€ scale.rs           // æ•°æ®ç¼©æ”¾å’Œæ˜ å°„
â”‚   â”œâ”€â”€ style.rs           // æ ·å¼å®šä¹‰
â”‚   â””â”€â”€ error.rs           // é”™è¯¯ç±»å‹å®šä¹‰
â””â”€â”€ Cargo.toml
```

**æ ¸å¿ƒç±»å‹**:
```rust
// åŸºç¡€åæ ‡ç±»å‹
pub struct Point2D { x: f64, y: f64 }
pub struct Point3D { x: f64, y: f64, z: f64 }

// å˜æ¢çŸ©é˜µ
pub struct Transform2D(Matrix3<f64>);
pub struct Transform3D(Matrix4<f64>);

// æ•°æ®ç¼©æ”¾
pub trait Scale {
    fn scale(&self, value: f64) -> f64;
    fn inverse_scale(&self, value: f64) -> f64;
}

// ç»Ÿä¸€é”™è¯¯ç±»å‹
#[derive(Debug, thiserror::Error)]
pub enum VizuaraError {
    #[error("Invalid data: {0}")]
    InvalidData(String),
    #[error("Rendering error: {0}")]
    RenderError(String),
    // ... å…¶ä»–é”™è¯¯ç±»å‹
}
```

### ğŸ¨ æ¸²æŸ“å¼•æ“å±‚

#### `vizuara-wgpu`
**èŒè´£**: GPU åŠ é€Ÿæ¸²æŸ“ï¼Œç€è‰²å™¨ç®¡ç†ï¼Œç¼“å†²åŒºæ“ä½œ

```rust
// æ¸²æŸ“å¼•æ“æ¶æ„
vizuara-wgpu/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs              // æ¸²æŸ“å™¨æ¥å£
â”‚   â”œâ”€â”€ renderer.rs         // ä¸»æ¸²æŸ“å™¨
â”‚   â”œâ”€â”€ renderer_3d.rs      // 3D æ¸²æŸ“å™¨
â”‚   â”œâ”€â”€ renderer_3d_lit.rs  // 3D å…‰ç…§æ¸²æŸ“å™¨
â”‚   â”œâ”€â”€ shader.rs           // ç€è‰²å™¨ç®¡ç†
â”‚   â”œâ”€â”€ vertex.rs           // é¡¶ç‚¹æ•°æ®ç»“æ„
â”‚   â””â”€â”€ shaders/            // å†…ç½®ç€è‰²å™¨ç›®å½•
â””â”€â”€ shaders/
    â”œâ”€â”€ shader_3d.wgsl      // 3D åŸºç¡€ç€è‰²å™¨
    â””â”€â”€ shader_3d_lit.wgsl  // 3D å…‰ç…§ç€è‰²å™¨
```

**æ¸²æŸ“ç®¡çº¿è®¾è®¡**:
```rust
pub trait Renderer {
    /// å¼€å§‹æ–°çš„æ¸²æŸ“å¸§
    fn begin_frame(&mut self) -> Result<(), VizuaraError>;
    
    /// æ¸²æŸ“å‡ ä½•å›¾å½¢
    fn render_geometry(&mut self, geometry: &Geometry) -> Result<(), VizuaraError>;
    
    /// ç»“æŸå½“å‰å¸§å¹¶æäº¤åˆ° GPU
    fn end_frame(&mut self) -> Result<(), VizuaraError>;
}

// GPU èµ„æºç®¡ç†
pub struct GpuResources {
    device: wgpu::Device,
    queue: wgpu::Queue,
    vertex_buffers: Vec<wgpu::Buffer>,
    index_buffers: Vec<wgpu::Buffer>,
    uniform_buffers: Vec<wgpu::Buffer>,
}
```

#### `vizuara-scene`
**èŒè´£**: åœºæ™¯å›¾ç®¡ç†ï¼Œå›¾å±‚ç³»ç»Ÿï¼Œæ¸²æŸ“è°ƒåº¦

```rust
// åœºæ™¯ç®¡ç†ç³»ç»Ÿ
pub struct Scene {
    layers: Vec<Layer>,
    camera: Camera,
    viewport: Viewport,
}

pub struct Layer {
    id: LayerId,
    objects: Vec<SceneObject>,
    visible: bool,
    z_order: i32,
}

pub trait SceneObject {
    fn render(&self, renderer: &mut dyn Renderer) -> Result<(), VizuaraError>;
    fn update(&mut self, delta_time: f64);
    fn get_bounds(&self) -> Bounds;
}
```

### ğŸ“Š åº”ç”¨é€»è¾‘å±‚

#### `vizuara-plots`
**èŒè´£**: 2D å›¾è¡¨ç±»å‹å®ç°

```rust
// å›¾è¡¨æ¨¡å—ç»“æ„
vizuara-plots/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs          // å›¾è¡¨ API å¯¼å‡º
â”‚   â”œâ”€â”€ scatter.rs      // æ•£ç‚¹å›¾
â”‚   â”œâ”€â”€ line.rs         // çº¿å›¾
â”‚   â”œâ”€â”€ bar.rs          // æŸ±çŠ¶å›¾
â”‚   â”œâ”€â”€ histogram.rs    // ç›´æ–¹å›¾
â”‚   â”œâ”€â”€ heatmap.rs      // çƒ­åŠ›å›¾
â”‚   â””â”€â”€ boxplot.rs      // ç®±çº¿å›¾
â””â”€â”€ Cargo.toml
```

**å›¾è¡¨è®¾è®¡æ¨¡å¼**:
```rust
// ç»Ÿä¸€çš„å›¾è¡¨æ¥å£
pub trait Plot {
    type Data;
    type Style;
    
    fn new(data: Self::Data, style: Self::Style) -> Result<Self, VizuaraError>;
    fn update_data(&mut self, data: Self::Data) -> Result<(), VizuaraError>;
    fn update_style(&mut self, style: Self::Style);
}

// æ¸²æŸ“èƒ½åŠ›
pub trait Renderable {
    fn render(&self, renderer: &mut dyn Renderer) -> Result<(), VizuaraError>;
}

// ä¸»é¢˜åº”ç”¨
pub trait Themeable {
    fn apply_theme(&mut self, theme: &Theme);
}

// ç¤ºä¾‹ï¼šæ•£ç‚¹å›¾å®ç°
pub struct ScatterPlot {
    data: Vec<Point2D>,
    style: ScatterStyle,
    cached_geometry: Option<Geometry>,
}

impl Plot for ScatterPlot {
    type Data = Vec<Point2D>;
    type Style = ScatterStyle;
    
    fn new(data: Self::Data, style: Self::Style) -> Result<Self, VizuaraError> {
        Ok(Self {
            data,
            style,
            cached_geometry: None,
        })
    }
}
```

#### `vizuara-3d`
**èŒè´£**: 3D å¯è§†åŒ–åŠŸèƒ½

```rust
// 3D æ¨¡å—æ¶æ„
vizuara-3d/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs          // 3D API å¯¼å‡º
â”‚   â”œâ”€â”€ scatter3d.rs    // 3D æ•£ç‚¹å›¾
â”‚   â”œâ”€â”€ surface.rs      // è¡¨é¢å›¾
â”‚   â”œâ”€â”€ mesh.rs         // ç½‘æ ¼å›¾
â”‚   â”œâ”€â”€ camera.rs       // ç›¸æœºæ§åˆ¶
â”‚   â””â”€â”€ lighting.rs     // å…‰ç…§ç³»ç»Ÿ
â””â”€â”€ Cargo.toml
```

**3D ç‰¹æœ‰åŠŸèƒ½**:
```rust
// 3D ç›¸æœºç³»ç»Ÿ
pub struct Camera3D {
    position: Point3D,
    target: Point3D,
    up: Vector3<f64>,
    fov: f64,
    aspect: f64,
    near: f64,
    far: f64,
}

impl Camera3D {
    pub fn view_matrix(&self) -> Matrix4<f64> { /* ... */ }
    pub fn projection_matrix(&self) -> Matrix4<f64> { /* ... */ }
}

// å…‰ç…§ç³»ç»Ÿ
pub struct Light {
    position: Point3D,
    color: Color,
    intensity: f64,
    light_type: LightType,
}

pub enum LightType {
    Directional(Vector3<f64>),
    Point,
    Spot { direction: Vector3<f64>, angle: f64 },
}
```

### ğŸ® åŠŸèƒ½æœåŠ¡å±‚

#### `vizuara-interactivity`
**èŒè´£**: ç”¨æˆ·äº¤äº’å¤„ç†ï¼Œäº‹ä»¶ç³»ç»Ÿ

```rust
// äº¤äº’ç³»ç»Ÿæ¶æ„
pub struct InteractionManager {
    tools: Vec<Box<dyn InteractiveTool>>,
    active_tool: Option<usize>,
    event_queue: VecDeque<InputEvent>,
}

pub trait InteractiveTool {
    fn handle_event(&mut self, event: &InputEvent) -> ToolResponse;
    fn update(&mut self, delta_time: f64);
    fn is_active(&self) -> bool;
}

// å†…ç½®äº¤äº’å·¥å…·
pub struct PanTool { /* å¹³ç§»å·¥å…· */ }
pub struct ZoomTool { /* ç¼©æ”¾å·¥å…· */ }
pub struct SelectTool { /* é€‰æ‹©å·¥å…· */ }

// äº‹ä»¶ç±»å‹
#[derive(Debug, Clone)]
pub enum InputEvent {
    MouseMove { pos: Point2D, delta: Vector2<f64> },
    MouseButton { button: MouseButton, state: ButtonState, pos: Point2D },
    MouseWheel { delta: f64, pos: Point2D },
    Keyboard { key: Key, state: ButtonState, modifiers: Modifiers },
}
```

#### `vizuara-animation`
**èŒè´£**: åŠ¨ç”»ç³»ç»Ÿï¼Œå…³é”®å¸§ï¼Œç¼“åŠ¨å‡½æ•°

```rust
// åŠ¨ç”»ç³»ç»Ÿæ ¸å¿ƒ
pub struct Timeline {
    animations: Vec<Animation>,
    current_time: f64,
    is_playing: bool,
}

pub struct Animation {
    keyframes: Vec<Keyframe>,
    duration: f64,
    easing: EasingFunction,
    target: AnimationTarget,
}

pub struct Keyframe {
    time: f64,
    value: AnimationValue,
}

// ç¼“åŠ¨å‡½æ•°
pub enum EasingFunction {
    Linear,
    EaseIn,
    EaseOut,
    EaseInOut,
    Bounce,
    Elastic,
    Custom(fn(f64) -> f64),
}

// åŠ¨ç”»ç›®æ ‡
pub enum AnimationTarget {
    Position(Point2D),
    Color(Color),
    Scale(f64),
    Rotation(f64),
    Custom(String),
}
```

#### `vizuara-themes`
**èŒè´£**: ä¸»é¢˜ç®¡ç†ï¼Œé¢œè‰²è°ƒè‰²æ¿

```rust
// ä¸»é¢˜ç³»ç»Ÿè®¾è®¡
pub struct Theme {
    name: String,
    colors: ColorPalette,
    typography: Typography,
    spacing: Spacing,
    effects: Effects,
}

pub struct ColorPalette {
    primary: Color,
    secondary: Color,
    background: Color,
    surface: Color,
    accent: Color,
    data_colors: Vec<Color>,
}

// ä¸»é¢˜æ„å»ºå™¨
pub struct ThemeBuilder {
    theme: Theme,
}

impl ThemeBuilder {
    pub fn new() -> Self { /* ... */ }
    pub fn name(mut self, name: &str) -> Self { /* ... */ }
    pub fn primary_color(mut self, color: Color) -> Self { /* ... */ }
    pub fn build(self) -> Theme { /* ... */ }
}

// é¢„è®¾ä¸»é¢˜
impl Theme {
    pub fn default() -> Self { /* ... */ }
    pub fn dark() -> Self { /* ... */ }
    pub fn light() -> Self { /* ... */ }
    pub fn colorful() -> Self { /* ... */ }
}
```

#### `vizuara-export`
**èŒè´£**: å›¾è¡¨å¯¼å‡ºåŠŸèƒ½

```rust
// å¯¼å‡ºç³»ç»Ÿ
pub trait Exporter {
    type Options;
    
    fn export<P: AsRef<Path>>(
        &self,
        scene: &Scene,
        path: P,
        options: Self::Options,
    ) -> Result<(), VizuaraError>;
}

// å…·ä½“å¯¼å‡ºå™¨å®ç°
pub struct PngExporter;
pub struct SvgExporter;
pub struct PdfExporter;

// å¯¼å‡ºé€‰é¡¹
pub struct ExportOptions {
    width: u32,
    height: u32,
    dpi: u32,
    background: Option<Color>,
    quality: f32,
}
```

### ğŸ–¼ï¸ ç”¨æˆ·æ¥å£å±‚

#### `vizuara-window`
**èŒè´£**: çª—å£ç®¡ç†ï¼Œå¹³å°æŠ½è±¡

```rust
// çª—å£ç³»ç»Ÿ
pub struct Window {
    inner: winit::window::Window,
    surface: wgpu::Surface,
    renderer: Box<dyn Renderer>,
    event_loop: Option<EventLoop<()>>,
}

impl Window {
    pub fn new(config: WindowConfig) -> Result<Self, VizuaraError> { /* ... */ }
    pub fn run(self, mut app: impl App + 'static) -> Result<(), VizuaraError> { /* ... */ }
}

// åº”ç”¨æ¥å£
pub trait App {
    fn update(&mut self, delta_time: f64);
    fn render(&mut self, renderer: &mut dyn Renderer) -> Result<(), VizuaraError>;
    fn handle_event(&mut self, event: &WindowEvent) -> EventResponse;
}
```

---

## ğŸ”„ æ•°æ®æµæ¶æ„

### ğŸ“Š æ•°æ®å¤„ç†ç®¡çº¿

```
åŸå§‹æ•°æ® â†’ æ•°æ®éªŒè¯ â†’ åæ ‡å˜æ¢ â†’ å‡ ä½•ç”Ÿæˆ â†’ GPUç¼“å†² â†’ æ¸²æŸ“
    â†“         â†“         â†“         â†“         â†“        â†“
[Vec<f64>] â†’ [Valid] â†’ [Scaled] â†’ [Vertex] â†’ [Buffer] â†’ [Frame]
```

**è¯¦ç»†æ•°æ®æµ**:

1. **æ•°æ®è¾“å…¥**: ç”¨æˆ·æä¾›åŸå§‹æ•°æ®ï¼ˆVecã€Arrayã€DataFrame ç­‰ï¼‰
2. **æ•°æ®éªŒè¯**: æ£€æŸ¥æ•°æ®æœ‰æ•ˆæ€§ï¼Œå¤„ç†ç¼ºå¤±å€¼å’Œå¼‚å¸¸å€¼
3. **åæ ‡å˜æ¢**: å°†æ•°æ®åæ ‡æ˜ å°„åˆ°å±å¹•åæ ‡ç³»ç»Ÿ
4. **å‡ ä½•ç”Ÿæˆ**: æ ¹æ®å›¾è¡¨ç±»å‹ç”Ÿæˆå¯¹åº”çš„å‡ ä½•å›¾å½¢
5. **GPU ä¼ è¾“**: å°†å‡ ä½•æ•°æ®ä¸Šä¼ åˆ° GPU ç¼“å†²åŒº
6. **æ¸²æŸ“è¾“å‡º**: GPU æ¸²æŸ“å¹¶è¾“å‡ºåˆ°å±å¹•æˆ–æ–‡ä»¶

### ğŸ¯ äº‹ä»¶å¤„ç†æµç¨‹

```
ç¡¬ä»¶äº‹ä»¶ â†’ ç³»ç»Ÿäº‹ä»¶ â†’ çª—å£äº‹ä»¶ â†’ åº”ç”¨äº‹ä»¶ â†’ å·¥å…·å¤„ç† â†’ åœºæ™¯æ›´æ–°
    â†“         â†“         â†“         â†“         â†“        â†“
[Raw Input] â†’ [WinIt] â†’ [Window] â†’ [App] â†’ [Tool] â†’ [Scene]
```

**äº‹ä»¶å¤„ç†æ­¥éª¤**:

1. **ç¡¬ä»¶è¾“å…¥**: é¼ æ ‡ã€é”®ç›˜ã€è§¦æ‘¸ç­‰åŸå§‹è¾“å…¥
2. **ç³»ç»Ÿå¤„ç†**: æ“ä½œç³»ç»Ÿå¤„ç†åŸå§‹è¾“å…¥å¹¶ç”Ÿæˆäº‹ä»¶
3. **çª—å£åˆ†å‘**: winit åº“æ¥æ”¶ç³»ç»Ÿäº‹ä»¶å¹¶åˆ†å‘ç»™çª—å£
4. **åº”ç”¨å¤„ç†**: åº”ç”¨å±‚æ¥æ”¶äº‹ä»¶å¹¶è¿›è¡Œåˆæ­¥å¤„ç†
5. **å·¥å…·å“åº”**: äº¤äº’å·¥å…·å¤„ç†ç‰¹å®šç±»å‹çš„äº‹ä»¶
6. **åœºæ™¯æ›´æ–°**: æ ¹æ®äº‹ä»¶ç»“æœæ›´æ–°åœºæ™¯çŠ¶æ€

---

## ğŸ§® å†…å­˜ç®¡ç†ç­–ç•¥

### ğŸ“¦ èµ„æºç”Ÿå‘½å‘¨æœŸ

**CPU ç«¯èµ„æº**:
```rust
// æ™ºèƒ½æŒ‡é’ˆä½¿ç”¨ç­–ç•¥
pub struct PlotData {
    raw_data: Arc<Vec<f64>>,          // å…±äº«åŸå§‹æ•°æ®
    processed: Rc<RefCell<Geometry>>, // å±€éƒ¨å‡ ä½•ç¼“å­˜
    style: Box<dyn PlotStyle>,        // å †åˆ†é…æ ·å¼
}

// å†™æ—¶å¤åˆ¶ä¼˜åŒ–
pub enum DataRef<'a> {
    Borrowed(&'a [f64]),
    Owned(Vec<f64>),
}
```

**GPU ç«¯èµ„æº**:
```rust
// GPU ç¼“å†²åŒºç®¡ç†
pub struct BufferPool {
    vertex_buffers: Vec<wgpu::Buffer>,
    index_buffers: Vec<wgpu::Buffer>,
    uniform_buffers: Vec<wgpu::Buffer>,
    free_list: Vec<usize>,
}

impl BufferPool {
    pub fn acquire(&mut self, size: u64) -> BufferHandle { /* ... */ }
    pub fn release(&mut self, handle: BufferHandle) { /* ... */ }
}
```

### ğŸ”„ ç¼“å­˜ç­–ç•¥

**å¤šçº§ç¼“å­˜ç³»ç»Ÿ**:
1. **L1 ç¼“å­˜**: é¢‘ç¹è®¿é—®çš„å‡ ä½•æ•°æ® (CPU å†…å­˜)
2. **L2 ç¼“å­˜**: GPU ç¼“å†²åŒºæ•°æ® (GPU å†…å­˜)
3. **L3 ç¼“å­˜**: é¢„è®¡ç®—çš„æ¸²æŸ“ç»“æœ (çº¹ç†ç¼“å­˜)

```rust
pub struct RenderCache {
    geometry_cache: LruCache<GeometryKey, Geometry>,
    texture_cache: LruCache<TextureKey, wgpu::Texture>,
    pipeline_cache: HashMap<PipelineKey, wgpu::RenderPipeline>,
}
```

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–æ¶æ„

### âš¡ å¹¶å‘å¤„ç†

**å¤šçº¿ç¨‹æ¶æ„**:
```rust
// å·¥ä½œçº¿ç¨‹æ± 
pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Job>,
}

// å¼‚æ­¥æ•°æ®å¤„ç†
pub async fn process_large_dataset(
    data: Vec<f64>,
    chunk_size: usize,
) -> Result<Vec<ProcessedChunk>, VizuaraError> {
    let chunks = data.chunks(chunk_size);
    let futures = chunks.map(|chunk| {
        tokio::spawn(async move {
            process_chunk(chunk).await
        })
    });
    
    try_join_all(futures).await
}
```

**GPU å¹¶è¡Œè®¡ç®—**:
```rust
// è®¡ç®—ç€è‰²å™¨ç”¨äºæ•°æ®é¢„å¤„ç†
#[repr(C)]
struct ComputeUniforms {
    data_size: u32,
    scale_factor: f32,
    offset: [f32; 2],
}

// å¹¶è¡Œå‡ ä½•ç”Ÿæˆ
fn generate_geometry_parallel(
    data: &[Point2D],
    style: &PlotStyle,
) -> Geometry {
    // ä½¿ç”¨ compute shader å¹¶è¡Œç”Ÿæˆé¡¶ç‚¹
}
```

### ğŸ¯ æ¸²æŸ“ä¼˜åŒ–

**æ‰¹å¤„ç†æ¸²æŸ“**:
```rust
pub struct RenderBatch {
    vertex_data: Vec<Vertex>,
    index_data: Vec<u32>,
    instance_data: Vec<InstanceData>,
    material: MaterialId,
}

impl RenderBatch {
    pub fn add_geometry(&mut self, geometry: &Geometry) { /* ... */ }
    pub fn render(&self, renderer: &mut dyn Renderer) { /* ... */ }
}
```

**å±‚æ¬¡ç»†èŠ‚ (LOD)**:
```rust
pub struct LodGeometry {
    high_detail: Geometry,    // < 1K é¡¶ç‚¹
    medium_detail: Geometry,  // < 10K é¡¶ç‚¹
    low_detail: Geometry,     // < 100K é¡¶ç‚¹
}

impl LodGeometry {
    pub fn select_lod(&self, distance: f64, screen_size: f64) -> &Geometry {
        if distance < 10.0 && screen_size > 0.1 {
            &self.high_detail
        } else if distance < 100.0 && screen_size > 0.01 {
            &self.medium_detail
        } else {
            &self.low_detail
        }
    }
}
```

---

## ğŸ”Œ æ‰©å±•æ€§è®¾è®¡

### ğŸ§© æ’ä»¶ç³»ç»Ÿ

```rust
// æ’ä»¶æ¥å£å®šä¹‰
pub trait Plugin {
    fn name(&self) -> &str;
    fn version(&self) -> &str;
    fn init(&mut self, context: &mut PluginContext) -> Result<(), PluginError>;
    fn update(&mut self, delta_time: f64);
    fn cleanup(&mut self);
}

// æ’ä»¶ç®¡ç†å™¨
pub struct PluginManager {
    plugins: Vec<Box<dyn Plugin>>,
    context: PluginContext,
}

impl PluginManager {
    pub fn load_plugin<P: Plugin + 'static>(&mut self, plugin: P) -> Result<(), PluginError> {
        let mut plugin = Box::new(plugin);
        plugin.init(&mut self.context)?;
        self.plugins.push(plugin);
        Ok(())
    }
}
```

### ğŸ¨ è‡ªå®šä¹‰æ¸²æŸ“å™¨

```rust
// æ¸²æŸ“å™¨æ‰©å±•æ¥å£
pub trait CustomRenderer: Renderer {
    fn supports_feature(&self, feature: RenderFeature) -> bool;
    fn create_custom_pipeline(&mut self, desc: &PipelineDescriptor) -> Result<PipelineId, VizuaraError>;
}

// è‡ªå®šä¹‰å›¾è¡¨ç±»å‹
pub trait CustomPlot: Plot + Renderable + Themeable {
    fn plot_type(&self) -> &'static str;
    fn register_with_engine(engine: &mut PlotEngine);
}
```

---

## ğŸ” å®‰å…¨æ€§è€ƒè™‘

### ğŸ›¡ï¸ å†…å­˜å®‰å…¨

**Rust è¯­è¨€çº§åˆ«ä¿è¯**:
- æ‰€æœ‰æƒç³»ç»Ÿé˜²æ­¢æ‚¬å‚æŒ‡é’ˆ
- å€Ÿç”¨æ£€æŸ¥å™¨é˜²æ­¢æ•°æ®ç«äº‰
- ç±»å‹ç³»ç»Ÿé˜²æ­¢ç©ºæŒ‡é’ˆè§£å¼•ç”¨

**é¢å¤–å®‰å…¨æªæ–½**:
```rust
// è¾“å…¥éªŒè¯
pub fn validate_plot_data(data: &[f64]) -> Result<(), ValidationError> {
    if data.is_empty() {
        return Err(ValidationError::EmptyData);
    }
    
    for &value in data {
        if !value.is_finite() {
            return Err(ValidationError::InvalidValue(value));
        }
    }
    
    Ok(())
}

// èµ„æºé™åˆ¶
pub struct ResourceLimits {
    max_vertices: usize,
    max_textures: usize,
    max_memory: usize,
}

impl ResourceLimits {
    pub fn check_vertex_count(&self, count: usize) -> Result<(), ResourceError> {
        if count > self.max_vertices {
            Err(ResourceError::TooManyVertices { count, max: self.max_vertices })
        } else {
            Ok(())
        }
    }
}
```

### ğŸ”’ GPU èµ„æºå®‰å…¨

```rust
// GPU èµ„æºRAIIç®¡ç†
pub struct GpuBuffer {
    buffer: wgpu::Buffer,
    size: u64,
    usage: wgpu::BufferUsages,
}

impl Drop for GpuBuffer {
    fn drop(&mut self) {
        // è‡ªåŠ¨æ¸…ç† GPU èµ„æº
        self.buffer.destroy();
    }
}

// å®‰å…¨çš„ç€è‰²å™¨åŠ è½½
pub fn load_shader_safe(
    device: &wgpu::Device,
    source: &str,
) -> Result<wgpu::ShaderModule, ShaderError> {
    // éªŒè¯ç€è‰²å™¨ä»£ç 
    validate_shader_source(source)?;
    
    // åˆ›å»ºç€è‰²å™¨æ¨¡å—
    let module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("Safe Shader"),
        source: wgpu::ShaderSource::Wgsl(source.into()),
    });
    
    Ok(module)
}
```

---

## ğŸ“Š ç›‘æ§ä¸è¯Šæ–­

### ğŸ“ˆ æ€§èƒ½ç›‘æ§

```rust
// æ€§èƒ½è®¡æ•°å™¨
pub struct PerformanceCounters {
    frame_time: MovingAverage<f64>,
    render_time: MovingAverage<f64>,
    gpu_memory_usage: AtomicU64,
    cpu_memory_usage: AtomicU64,
    draw_calls: AtomicU32,
}

impl PerformanceCounters {
    pub fn record_frame_time(&self, time: f64) {
        self.frame_time.add_sample(time);
    }
    
    pub fn get_fps(&self) -> f64 {
        1.0 / self.frame_time.average()
    }
}

// æ€§èƒ½åˆ†æå™¨
pub struct Profiler {
    sections: HashMap<String, ProfileSection>,
    current_frame: u64,
}

impl Profiler {
    pub fn begin_section(&mut self, name: &str) {
        let section = self.sections.entry(name.to_string())
            .or_insert_with(ProfileSection::new);
        section.begin();
    }
    
    pub fn end_section(&mut self, name: &str) {
        if let Some(section) = self.sections.get_mut(name) {
            section.end();
        }
    }
}
```

### ğŸ› è°ƒè¯•æ”¯æŒ

```rust
// è°ƒè¯•æ¸²æŸ“å™¨
#[cfg(debug_assertions)]
pub struct DebugRenderer {
    base_renderer: Box<dyn Renderer>,
    debug_lines: Vec<DebugLine>,
    debug_texts: Vec<DebugText>,
}

impl DebugRenderer {
    pub fn draw_debug_line(&mut self, start: Point2D, end: Point2D, color: Color) {
        self.debug_lines.push(DebugLine { start, end, color });
    }
    
    pub fn draw_debug_text(&mut self, text: &str, pos: Point2D, color: Color) {
        self.debug_texts.push(DebugText {
            text: text.to_string(),
            position: pos,
            color,
        });
    }
}

// é”™è¯¯æŠ¥å‘Š
pub struct ErrorReporter {
    errors: Vec<ErrorReport>,
    max_errors: usize,
}

pub struct ErrorReport {
    error: VizuaraError,
    timestamp: std::time::Instant,
    context: String,
    stack_trace: Option<String>,
}
```

---

## ğŸ”® æœªæ¥æ¶æ„æ¼”è¿›

### ğŸŒ åˆ†å¸ƒå¼æ¶æ„

**äº‘ç«¯æ¸²æŸ“æ”¯æŒ**:
```rust
// åˆ†å¸ƒå¼æ¸²æŸ“æ¥å£
pub trait DistributedRenderer {
    async fn render_remote(
        &self,
        scene: &Scene,
        target: RenderTarget,
    ) -> Result<RenderResult, DistributedError>;
    
    fn get_available_nodes(&self) -> Vec<RenderNode>;
}

// æ¸²æŸ“èŠ‚ç‚¹æŠ½è±¡
pub struct RenderNode {
    id: NodeId,
    capabilities: RenderCapabilities,
    load: f32,
    latency: Duration,
}
```

### ğŸ¤– AI é›†æˆ

**æ™ºèƒ½å¯è§†åŒ–**:
```rust
// AI è¾…åŠ©çš„å¯è§†åŒ–æ¨è
pub trait VisualizationAI {
    fn suggest_chart_type(&self, data: &DataSet) -> Vec<ChartSuggestion>;
    fn optimize_layout(&self, scene: &Scene) -> LayoutOptimization;
    fn detect_patterns(&self, data: &DataSet) -> Vec<Pattern>;
}

// è‡ªåŠ¨åŒ–å›¾è¡¨ç”Ÿæˆ
pub struct AutoChartGenerator {
    ai_engine: Box<dyn VisualizationAI>,
    template_library: TemplateLibrary,
}
```

### ğŸ“± å¤šç«¯ç»Ÿä¸€

**è·¨ç«¯æ¶æ„**:
```rust
// å¹³å°æŠ½è±¡å±‚
pub trait Platform {
    type Window: PlatformWindow;
    type Renderer: PlatformRenderer;
    type Input: PlatformInput;
    
    fn create_window(&self, config: WindowConfig) -> Result<Self::Window, PlatformError>;
    fn create_renderer(&self, window: &Self::Window) -> Result<Self::Renderer, PlatformError>;
}

// å…·ä½“å¹³å°å®ç°
pub struct DesktopPlatform;
pub struct WebPlatform;
pub struct MobilePlatform;
```

---

## ğŸ“š æ¶æ„æ–‡æ¡£ç»´æŠ¤

### ğŸ”„ ç‰ˆæœ¬æ§åˆ¶

**æ¶æ„å†³ç­–è®°å½• (ADR)**:
- æ¯ä¸ªé‡è¦æ¶æ„å†³ç­–éƒ½æœ‰å¯¹åº”çš„ ADR æ–‡æ¡£
- è®°å½•å†³ç­–èƒŒæ™¯ã€è€ƒè™‘çš„é€‰é¡¹ã€æœ€ç»ˆå†³ç­–å’Œåæœ
- å®šæœŸå›é¡¾å’Œæ›´æ–°è¿‡æ—¶çš„å†³ç­–

**API ç¨³å®šæ€§ä¿è¯**:
- å…¬å…± API ä½¿ç”¨è¯­ä¹‰åŒ–ç‰ˆæœ¬æ§åˆ¶
- ç ´åæ€§å˜æ›´éœ€è¦è¯¦ç»†çš„è¿ç§»æŒ‡å—
- æä¾›å¼ƒç”¨å‘¨æœŸæ¥å¹³æ»‘è¿‡æ¸¡

### ğŸ“– æ–‡æ¡£åŒæ­¥

**è‡ªåŠ¨åŒ–æ–‡æ¡£ç”Ÿæˆ**:
- ä»£ç æ³¨é‡Šè‡ªåŠ¨ç”Ÿæˆ API æ–‡æ¡£
- æ¶æ„å›¾è¡¨ä¸ä»£ç åŒæ­¥æ›´æ–°
- ç¤ºä¾‹ä»£ç è‡ªåŠ¨æµ‹è¯•ç¡®ä¿æœ‰æ•ˆæ€§

---

*æœ¬æ¶æ„æ–‡æ¡£æ˜¯æ´»æ–‡æ¡£ï¼Œéšç€é¡¹ç›®å‘å±•æŒç»­æ›´æ–°ã€‚*

**ç»´æŠ¤è€…**: Vizuara å¼€å‘å›¢é˜Ÿ  
**æ›´æ–°é¢‘ç‡**: é‡å¤§æ¶æ„å˜æ›´æ—¶  
**åé¦ˆæ¸ é“**: GitHub Issues / æ¶æ„è®¨è®ºåŒº
